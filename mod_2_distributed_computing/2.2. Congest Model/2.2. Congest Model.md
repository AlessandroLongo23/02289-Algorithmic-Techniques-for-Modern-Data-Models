## Congest Model
In the congest mode, we still have the same network of $n$ computers (nodes) connected via communication channels (edges). As for the local model, nodes can exchange **messages** with neighbors during **communication rounds**, in the same way as before.
The difference is that the message have a upper bound on their size: in each round, over each edge, the message send at most $O(\log(n))$ bits.
The operations order in each communication round is send first and receive seconds, while the local computation can occur at any point.
We want to solve instances of a graph problem with a distributed algorithm using few communication rounds. The communication network **is** the graph instance.
Each node is a machine that should output its part of the solution
- - -
## Single-Source Shortest Path Distance Problem (SSSP)
Let $G=(V,E)$ be an unweighted undirected $n$-node connected graph.
One node $s$ starts with input $1$, all others with input $0$
The local output for each node $v$ is its distance from/to root $s$:
$$\text{dist}_G(s,v)=\text{dist}_G(v,s)$$
We show that SSSP can be solved in $O(\text{diam}(G))$ communication rounds, where $\text{diam}(G)$ is the diameter of the graph $G$, defined as:
$$\text{diam}(G)=\max_{u,v\in V}\text{dist}_G(u,v)$$
### The Wave Algorithm
#### Algorithm
At round $i=0$, the root $s$ sends a message $\texttt{wave}$ to its neighbors, switches to state $0$ and stops.
At round $i>0$: for each node $v$ that has not stopped and has received at least one message $\texttt{wave}$ in round $i-1$, $v$ sends $\texttt{wave}$ to its neighbors, switches to state $i$ and stops.
![[wave-algorithm.gif|400]]
#### Correctness
For each $i\ge 0$, every node $v$ with $\text{dist}_G(s,v)=i$ outputs $i$ and stops in round $i$.
The proof can be done by induction on $i\ge0$.
#### Number of communication rounds
Each node $v$ has distance $\text{dist}_G(s,v)\le\text{diam}(G)$ from $s$, thus it stops in round $\text{diam}(G)$ at the latest, therefore, the number of communication rounds is $O(\text{diam}(G))$.
#### Considerations
The Wave algorithm only computes distances from $s$ to each node $v\in V$. In other words, that is only information contained in each node at the end of the execution. If we want to also retain information about the structure of the graph, we need to implement something slightly more complex.
### Breadth-First Search (BFS) Tree
#### Goal
We now want to compute the shortest path tree $T$ from $s$. So instead of just storing the distance $d(v)=\text{dist}_G(s,v)=\text{dist}_G(v,s)$, we will also label each $v\in V$ with a parent (except the source $s$) and a list of children.
#### Node attributes
During the BFS algorithm, each node $v\in V$ maintains the following for the partially constructed BFS tree $T$:
- $d(v)$: distance to the root $s$
- $p(v)$: parent node in $T$
- $C(v)$: set of children of $v$ in $T$
- $a(v)$: acknowledgment, equals $1$ when the subtree rooted at $v$ is constructed, $0$ otherwise

#### BFS initialization
Initial $T$ is empty, so we initialize, for each $v$:
- $d(v)=\perp$ for $v\ne s$ and $d(v)=0$ for $v=s$
- $p(v)=\perp$
- $C(v)=\perp$
- $a(v)=0$

Example of an initial tree with $d$-values:
![[BFS initialization.png]]
#### Forward pass: the Wave
For each node $u$ with $d(u)\ne\perp$, $u$ sends $d(u)$ to its neighbors.
Each node $v$ with $d(v)=\perp$ receiving a value $j$ from a node $u$:
- set $p(v)=u$
- set $d(v)=j+1$
- send "accept" back to $u$ in the next round
- if $v$ receives messages from multiple nodes, ignore all except one

![[forward-pass.gif|300]]
Each node $u$ sets $C(u)$ to the set of nodes it received "accept" from:
- $C(u)$ is exactly the set of nodes $v$ with $p(v)=u$
- $C(u)=\emptyset$ if $u$ is a leaf
```ad-Esempio
![[example.jpg|300]]

In this example:
- $C(s)=\{a,d\}$
- $C(a)=\{b,c\}$
- $C(b)=\emptyset$
- $C(c)=\emptyset$
- $C(d)=\{e\}$
- $C(e)=\emptyset$
```
#### Backward pass: the Acknowledgment
"ack" message is sent from a node $v$ to its parent once the subtree rooted at $v$ is constructed.
For each node $u$ with $C(u)\ne\perp$ and $a(u)=0$:
- once $u$ has received message "ack" from each $v\in C(u)$, it sets $a(u)=1$ since its subtree is constructed
- if $p(v)\ne\perp$, then sends "ack" to $p(v)$
- if $u$ is a leaf, $C(u)=\emptyset$, so $u$ doesn't wait for any "ack" messages

![[backward-pass.gif|300]]
#### Time Complexity
It takes $O(\text{diam}(G))$ rounds to compute $d(v)$ and $p(v)$ for each $v$. Each round adds another BFS layer to $T$. It then takes an additional $O(\text{diam}(G))$ rounds to set $a(v)=1$ and send "ack" messages back towards $s$.
The total number of rounds is $O(\text{diam}(G))$.
- - -
## Electing a leader
### Problem definition
Exactly one node $s$, called the leader, should output $1$, and all others should output $0$. We will solve this problem in $O(\text{diam}(G))$ communication rounds.
Electing a leader is useful when we want one node to take charge in solving a problem.
Will be needed as part of our APSP algorithm.
### Idea and obstacles
The algorithm we describe here is for electing the leader with the smallest node id.
- run BFS from each possible root node in parallel
- extend BFS algorithm's messages with the root node's id
- each node $v$ keeps track of the smallest root node id among the BFSs that have visited $v$
- when all BFSs have completed, all nodes will have stored the smallest node id in the graph and this is the elected leader

The problem with this algorithm is that it can take up to $\Theta(n)$ messages sent along a single edge in one communication round, since $n=|V|$, but the congest model only allows $O(\log(n))$ bit messages.
### Small messages version
We can make a modification to the algorithm to ensure small messages. Suppose $l(v)$ is the current smallest root id for a node $v$: in each round, $v$ only sends messages for the BFS of root id $l(v)$. The messages to $v$ from all other BFSs are simply ignored since they're not needed to elect the leader.
The message size is $O(\log(n))$, which is within the constraints.
![[Small messages version.png]]
Let $s$ be the node with the smallest id. The BFS from $s$ eventually reaches each node $v$, thus, the final update to $l(v)$ is $l(v)=s$. The "ack" messages for the BFS of $s$ will eventually reach $s$, indicating that $s$ has grown a full BFS tree.
For each node $s'\ne s$, the BFS tree of $s'$ will never be completed: $s$, and possibly other nodes, ignore messages for the BFS of $s'$. Thus, $s'$ will not receive "ack" messages for its own BFS.
At termination, once $s$ knows it is the leader, it informs the other nodes of this with another BFS. Only then, $s$ outputs $1$, and all other nodes output $0$.
The number of communication rounds is again $O(\text{diam}(G))$.
- - -
## All-Pairs Shortest Path problem (APSP)
### Problem definition
Let $G=(V,E)$ be an unweighted undirected $n$-node connected graph.
The problem is now to compute $\text{dist}_G(u,v)$ for all $u,v\in V$.
The local output of each $v\in V$ is a dictionary (key-value) of all nodes and their distance:
$$\{(u,d):u\in V,d=\text{dist}_G(u,v)\}$$
We will show that APSP can be solved in $O(n)$ communication rounds, which is asymptotically optimal as there's a $\Omega(n)$ lower bound.
### Non-interfering waves
Suppose we start the $\texttt{Wave}$ algorithm at node $u$ in communication round $t_u$ and at node $v$ in communication round $t_v>t_u$. Then no node will send more than one message in any round for the two $\texttt{Wave}$ algorithms if:
$$t_v-t_u>\text{dist}_G(u,v)$$
The idea is that since the two waves spread $1$ unit per round, $v$'s wave starts too late to ever catch up with $u$'s wave.
```ad-Esempio
title: Example
- $t_u=1$
- $t_v=4$
- $\text{dist}_G(u,v)=2$

The inequality is satisfied:
$$t_v-t_u=3>2=\text{dist}_G(u,v)$$
![[non-interfering.gif|300]]
```
```ad-Dimostrazione
title: Proof by contraposition
Assume some $w$ sends a wave twice in the same round $t$, one oroginating from $u$ and one from $v$, i.e., we have an interference.
We need to show the opposite inequality:
$$t_v-t_u\le\text{dist}_G(u,v)$$
![[]]
By the triangle inequality:
$$\text{dist}_G(u,w)\le\text{dist}_G(u,v)+\text{dist}_G(v,w)\iff$$
$$\text{dist}_G(u,w)-\text{dist}_G(v,w)\le\text{dist}_G(u,v)$$

- It takes $\text{dist}_G(u,w)$ rounds for the wave to reach $w$ from $u$
- It takes $\text{dist}_G(v,w)$ rounds for the wave to reach $w$ from $v$

Since $w$ sends wave originating from both $u$ and $v$ in round $t$:

$$t=t_u+\text{dist}_G(u,w)=t_v+\text{dist}_G(v,w)\iff$$
$$t_v-t_u=\text{dist}_G(u,w)-\text{dist}_G(v,w)\le\text{dist}_G(u,v)$$
```
### Moving token
A BFS tree $T$ is constructed from an elected leader $s$:
![[]]
Let $W$ be a DFS walk of $T$, starting and ending in $s$:
![[]]
A token $\tau$ is then sent around $T$, following $W$. When a vertex $v$ has $\tau$, it:
- starts the Wave algorithm if it has not previously had the token
- waits a turn before passing $\tau$ onto the next vertex of $W$

![[token.gif|400]]
We want to show our earlier inequality: for any $u$ and $v$ with $t_u>t_v$, the waves for $u$ and $v$ do not interfere:
$$t_v-t_u>\text{dist}_G(u,v)$$
- $t_u$ is the earliest round when $u$ has token $\tau$
- $t_v$ is the earliest round when $v$ has token $\tau$
- $\tau$ moves from $u$ to $v$ between rounds $t_u$ and $t_v$
- let $\text{dist}_W(u,v)$ be the number of edges traversed by $\tau$ between these rounds
- the round number increases by $2$ each time $\tau$ moves by one edge, so:

$$t_v-t_u=2\text{dist}_W(u,v)\ge2\text{dist}_G(u,v)>\text{dist}_G(u,v)$$
Since this holds for any $u$ and $v$, no waves can interfere.
Thus, the bandwidth requirement of the Congest model is satisfied: each message is only $O(\log(n))$ bits long.
Computing the initial BFS tree $T$ takes $O(\text{diam}(G))$ rounds
Walk $W$ visits each edge of $T$ twice.
$T$ has $n-1$ edges, so the token moves $2n-2$ times
It moves every second round, so $O(n)$ rounds to complete the walk.
Thus, every execution of $\texttt{Wave}$ starts within $O(n)$ rounds and takes an additional $O(\text{diam}(G))$ rounds to finish.
The total number of rounds for our APSP algorithm is:
$$O(n+\text{diam}(G))=O(n)$$
- - -