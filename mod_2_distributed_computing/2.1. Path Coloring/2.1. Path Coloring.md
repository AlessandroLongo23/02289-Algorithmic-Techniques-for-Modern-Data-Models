## Local model
Network with $n$ computers (nodes) connected via communication channels (edges).
![[general model.png]]
In this model:
- each node has a unique identifier: $V\to\{1,2,\ldots,n^c\}$ for some constant $c$, and $n=|V|$
- nodes can exchange **messages** with neighbors during **communication rounds**, during which all nodes perform the same algorithm synchronously in parallel:
	- receive messages
	- process
	- send

## Path coloring
The $\texttt{PathColoring}$ problem consists of assign a color to all nodes such that no neighboring nodes have the same color.
![[path coloring.png]]
Particularly, the goal of $\texttt{3-coloring}$ is to only use three colors $\{1,2,3\}$.
This is impossible without unique identifiers or randomness. So either:
- Each node has a unique name/identifier:
  ![[unique id.png]]
- each node has a source of random bits:
  ![[random bits.png]]
## P3C algorithm
### Algorithm
Let's assume that we have unique identifiers:
```
c = id
while true:
	send message c to all neighbors
	receive messages M from neighbors
	if c is not {1,2,3} and c biggest among all messages received this round
		c = min({1,2,3} - M)
```
```ad-Esempio
title: Example
![[P3C 1.png]]
![[P3C 2.png]]
![[P3C 3.png]]
![[P3C 4.png]]
![[P3C 5.png]]
![[P3C 6.png]]
![[P3C 7.png]]
![[P3C 8.png]]
![[P3C 9.png]]
![[P3C 10.png]]
![[P3C 11.png]]
```
- - -
## Faster deterministic path coloring
### Assumptions
Assume again unique identifiers and a directed path:
![[FDPC.png]]
Algorithm runs in rounds, and in each round:
- reduce the number of colors from $2^x$ to $2x$
- maintain that is a proper coloring

### Algorithm
The round for each node $u$ with color $c(u)$ consists of:
- sending color to predecessor
- know current color $c_o(u)=c(u)$ and color of successor $c_1(u)$. Consider their bit representation
- compute:
	- $i(u)$: the index of the first bit where $c_0(u)$ and $c_1(u)$ differ
	- $b(u)$: the value of bit $i(u)$ in $c_0(u)$
	- set $c(u)=2\cdot i(u)+b(u)$

### Correctness
If we had a proper coloring, then it is still a proper coloring:
![[FDPC correctness.png]]
We want to show that $c(u)\ne c(v)$ leads to $c_0(u)\ne c_1(u)$. We have two cases:
- $i(u)=i(v)=i$: then $b(u)\ne b(v)\implies c(u)\ne c(v)$
- $i(u)\ne i(v)$: no matter how we choose $b(u)\in\{0,1\}$ and $b(v)\in\{0,1\}$, then $c(u)=2\cdot i(u)+b(u)\ne 2\cdot i(v)+b(v)=c(v)$

The reduction in number of colors:
- need $x$ bits to represent the $2^x$ different colors
- number of different colors is $2x$: we have $0\le c(u)\le 2x-1$

This logic is applied for $O(\log_2^*(n))$ rounds, where $\log_2^*(n)$ means how many times you have to take the $\log_2(n)$ to get to $1$, which is a very small number. It's the opposite of tetration.
```ad-Esempio
- $\log_2^*(2)=1\iff ^12=2$
- $\log_2^*(4)=2\iff ^22=4$
- $\log_2^*(16)=3\iff ^32=2^{2^2}=16$
- $\log_2^*(65536)=4\iff ^42=2^{2^{2^2}}=2^{2^4}=2^{16}=65536$
```
In particular, we want to reduce the colors until we get to $6$, then we can use PC3 to get down to $3$.
In fact, it can be shown that once you get to $6$ colors, you can't reduce the number of colors anymore.
- - -
## Randomized path coloring
Each node $u$ has a flag $s(u)$ that indicates it has stopped.
In each round:
- each node $u$ that is not stopped picks a color $c(u)\in\{1,2,3\}$ uniformly at random
- send new color $c(u)$ to neighbors
- if the new color is different from the neighbors colors, set $s(u)=1$
- - -