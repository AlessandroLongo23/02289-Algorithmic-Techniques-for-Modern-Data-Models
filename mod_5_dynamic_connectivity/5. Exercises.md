## Exercise 5.1: Worst-case time #toSolve
### Problem
#### Part 1
What is the worst-case update time of the data structure in the slides?
#### Part 2
What is its worst-case query time?
### Solution
#### Part 1

#### Part 2

- - -
## Exercise 5.2: Search procedures with distinct number of edges explored #toSolve
### Problem
In the examples in the slides showing the two parallel search procedures after an edge deletion, they both have the same number of edges to explore $\pm1$. This is not true in general.
In the general case, let $P_u$ and $P_v$ be the search procedure from $C_u$ and from $C_v$, respectively. We use the following approach to handle an edge detection and consider two cases similar to those in the slides:
- The two search procedures visit the same cluster $C_{uv}$ (the parent cluster is not split). Assume $C_{uv}$ was first visited by $P_u$ (the other case is symmetric). Let $\mathcal C_u$ be the clusters visited by $P_u$. Let $\mathcal C_v$ be the clusters visited by $P_v$, excluding $C_{uv}$. If $\sum_{w\in\mathcal C_u}n(w)\le\sum_{w\in\mathcal C_v}n(w)$, the edges visited by $P_u$ are contracted; otherwise, the edges visited by $P_v$ are contracted
- the two search procedures visit disjoint sets of clusters (the parent cluster is split). Assume $P_u$ is the first to finish (the other case is symmetric). Then the levels of edges explored by $P_u$ are increased, provided that this doesn't violate the invariant. If the invariant is violated, then $P_v$ finishes its search (visiting all remaining edges reachable from $C_v$) and the levels of its visited edges are increased.

Argue that the invariant is maintained using the above approach and show that the edge level increases suffice to pay the two search procedures (use the same level of detail as in the slides).
### Solution

- - -
## Exercise 5.3: Updates to example graph #toSolve
### Problem
The following examples shows a graph $G$ with edge levels indicated.
![[]]
#### Part 1
Explain why the invariant of the data structure for $G$ is violated.
#### Part 2
Consider a modified version of $G$ where $k$ isolated vertices are added. Show that $k=11$ is the smallest $k$ needed to satisfy the invariant. What is $l_\max$ for this value of $k$?
#### Part 3
Show the cluster forest $\mathcal C$ for $G$ with $k=11$. You may ignore the $k$ isolated vertices in your drawing.
#### Part 4
Show $G$ and $\mathcal C$ after $\text{insert}(c,e)$. What changes occur in $\mathcal C$?
#### Part 5
Show $G$ and $\mathcal C$ after the additional update $\text{delete}(d,f)$, i.e., after $\text{insert}(c,e)$
#### Part 6
Show $G$ and $\mathcal C$ after the additional update $\text{delete}(c,e)$, i.e., after $\text{insert}(c,e)$ and $\text{delete}(d,f)$
### Solution
#### Part 1

#### Part 2

#### Part 3

#### Part 4

#### Part 5

#### Part 6

- - -
## Exercise 5.4: Cluster sizes and edge-bitmaps #toSolve
### Problem
#### Part 1
Show bitmaps $\text{edge}(u)$ and sizes $n(u)$ for all nodes $u$ in the cluster forest $\mathcal C$ that you obtained in Exercise 3.3
#### Part 2
Show that $\text{edge}(w)$ is the bitwise or of $\text{edge}(u)$ and $\text{edge}(v)$ where $C(w)$ is the merge of $C(u)$ and $C(v)$.
### Solution
#### Part 1

#### Part 2

- - -
## Exercise 5.5: Local trees #toSolve
### Problem
Let node $u$ have children $a$, $b$, and $c$ in $\mathcal C$ with $n(a)=1$, $n(b)=4$, and $n(c)=5$. Let another node $v$ have children $d,e,f$ and $g$ with $n(d)=n(e)=2$ and $n(f)=n(g)=4$.
#### Part 1
Show local trees $L(u)$ and $L(v)$
#### Part 2
Suppose an update to $G$ results in merging $u$ and $v$ into $u$. Using the description in the first paragraph of section 3.6 of [1], show how to obtain $L(u)$ resulting from the merge.
#### Part 3
Argue that the worst-case time to merge two local trees is $O(\log(n))$ and why this is not a problem for the amortized analysis.
```ad-hint
title: Hint
The number of clusters pairs merged is at least the number of edge level increases.
```
#### Part 4
An edge deletion in $G$ may also involve splitting a cluster (or multiple clusters) as we saw in the lecture. Explain how to split the corresponding local tree in two in $O(\log(n))$ time. Argue that this is not a problem for the amortized analysis.
```ad-hint
title: Hint
For the last part, show that only $O(\log(n))$ clusters can be split per edge deleted in $G$.
```

### Solution
#### Part 1

#### Part 2

#### Part 3

#### Part 4

- - -
## Exercise 5.6: Height of $\mathcal C_L$ #toSolve
### Problem
Show that $\mathcal C_L$ has height $O(\log(n))$, where $n=|V|$.
```ad-hint
title: Hint
Show first that for a node $u$ and a child $v$ of $u$ in $\mathcal C_L$, $v$ has depth at most $\log_2\left(\dfrac{n(u)}{n(v)}\right)+O(1)$ in $L(u)$. Then use a telescopi sums argument.
```
### Solution

- - -
## Exercise 5.7: Initial/final graph #toSolve
### Problem
In [1], it is assumed that we start with $E=\emptyset$.
#### Part 1
Why is this important for the analysis?
#### Part 2
Adapt and analyze the data structure for the case where we start with $E$ arbitrary and end the update sequence with $E=\emptyset$. What's the amortized update time for the adapted data structure?
#### Part 3
How bad can the amortized update time be if we don't assume that $E$ is empty at the beginning nor at the end of the update sequence?
### Solution
#### Part 1

#### Part 2

#### Part 3

- - -
## Exercise 5.8: Balanced binary search trees #toSolve
### Problem
As explained in [1], each leaf of $\mathcal C_L$ has a balanced binary search tree (BBST)
#### Part 1
Explain how the BBSTs are used by the data structure
#### Part 2
Explain why for the $O(\log^2(n))$ amortized update bound, these BBSTs are not needed. What simpler data structure can be used instead in each leaf? Try to avoid increasing the $O(m+n\log(n))$ space bound.
### Solution
#### Part 1

#### Part 2

- - -
## Exercise 5.9: Incremental connectivity #toSolve
### Problem
In the incremental connectivity problem, we only allow insertions. As mentioned in [1], this can be viewed as the union-find problem. Explain why this is the case.
### Solution

- - -