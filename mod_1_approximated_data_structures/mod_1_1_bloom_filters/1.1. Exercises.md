## Exercise 1.1.1: Bloom filter #solved
### Problem
Let:
- $m=17$,
- $h_1(x)=(x+15)\text{ mod }m$
- $h_2(x)=(4x+11)\text{ mod }m$
- $h_3(x)=(7x+2)\text{ mod }m$

Insert the keys $23,7,50$ and $91$ into the bit vector, and show the resulting vectors content. Then, find a key that is a false positive.
### Solution
See code
- - -
## Exercise 1.1.2: Expected number of zeroes #solved
### Problem
Let $p$ be the probability that a specific bit $b$ is zero after inserting $n$ elements in the Bloom filter (we calculated the value of $p$ in class). Let $Z$ be the number of bits in the Bloom filter that are zero after inserting $n$ elements.
Show that the expected value of $Z$ is $mp$.
### Solution
Let's define the indicator variable $X_i$ as follows:
$$X_i=\begin{cases}
1&\text{if bit }i\text{ is }0\\
0&\text{if bit }i\text{ is }1\\
\end{cases}$$
Thus, $Z$ can be expressed as:
$$Z=\sum_{i=1}^mX_i$$
And we insert $n$ elements, we get:
$$\mathbb E[Z]=\mathbb E\left[\sum_{i=1}X_i\right]=\sum_i\mathbb E[X_i]=\sum_ip=mp$$
- - -
## Exercise 1.1.3: Union and intersection #solved
### Problem
#### Part 1
Suppose you have two Bloom filters $F_A$ and $F_B$ representing two sets $A$ and $B$. The two Bloom filters are created using the same number of bits $m$ and the same $k$ hash functions.
Let $F_\text{OR}$ be a new Bloom filter formed by computing the bitwise $\text{OR}$ of $F_A$ and $F_B$. Is this the same as the Bloom filter constructed by adding the elements of $A\cup B$ one at a time?
#### Part 2
Let $F_\text{AND}$ be the bloom filter formed by computing the bitwise $\text{AND}$ of $F_A$ and $F_B$. Argue that this is not the same as the Bloom filter constructed by adding the elements of $A\cap B$ one at a time.
#### Part 3
Argue that $F_\text{AND}$ can be used to check if an element $x$ is in the set $A\cap B$ with one sided error. That is, give an algorithm that always returns $\texttt{True}$ if $x\in A\cap B$, and explain how we can get false-positives.
### Solution
#### Part 1
Yes, it's the same because "turning on" a bit in the hash table follows itself an OR logic, even across the elements of the same set. We can also think about this as first inserting all elements from $A$ and then from $B$, regardless of duplicate elements, since adding multiple times the same element isn't different from adding it only once.
#### Part 2
A counterexample of this could be with two sets $A=\{a\}$ and $B=\{b\}$, with $a\ne b$, but such that $\exists i:h_i(a)=h_i(b)$. In this case bit $1$ would be in $F_\text{AND}$, but $A\cap B=\emptyset$.
#### Part 3
What we just described is an example of the one-sided error, i.e., false positives. As for the false negatives, it's not possible to encounter them because if there's an element $x\in A\cap B$, then all bits turned to $1$ because of $x$ would also be $1$ in $F_A$ and $F_B$ separately, because they both contain $x$.
- - -
## Exercise 1.1.4: Dynamic size #solved #toTranscribe
### Exercise
Bloom filters can easily be halved in size, allowing an application to dynamically shrink a Bloom filter. Suppose that the size of the filter is a power of $2$. To halve the size of the filter, just OR the first and second halves together.
Explain how to do a lookup in the new table.
### Solution

- - -
## Exercise 1.1.5: Set differences #solved #toTranscribe
### Problem
Bloom filters can be used to estimate set differences. Suppose you have two sets $X$ and $Y$ representing two peoples $100$ favorite songs. Let $F_X$ and $F_Y$ be the Bloom filters of the two sets created using the same number of bits $m$ and the same $k$ hash functions.
#### Part 5.1
What is the probability that a given bit $b$ is $1$ in $F_X$ and $0$ in $F_Y$? The answer should be given as a function of $m$, $k$, and $|X\cap Y|$.
*Hint: The following notation can be useful: for a set $S$ of songs, let $\text{bit}(S)$ denote the set of bits that are one after (only) the elements in $S$ are inserted in the Bloom filter, i.e., $$\text{bit}(S)=\{b:\exists x\in S,j\in\{1,\ldots,k\}\text{ such that }h_j(x)=b\}$$*
#### Part 5.2
Determine the expected number of bits where the two Bloom filters differs as a function of $m$,$k$, and $|X\cap Y|$.
#### Part 5.3
Explain how this could be used as a tool to find people with the same taste in music more easily than comparing the lists of songs directly.
### Solution
#### Part 5.1

#### Part 5.2

#### Part 5.3

- - -
## Exercise 1.1.6: Deletion #solved #toTranscribe
### Problem
Suppose that we want to extend Bloom filters to allow deletions as well as insertions of items into the underlying set. We could modify the Bloom filter to be an array of counters instead of an array of bits. Each time an item is inserted into a Bloom filter, the counter given by the hashes of the item are increased by one. To delete an item, one can simply decrement the counters. To keep space small, the counters should be a fixed length, such as $4$ bits.
Explain how errors can arise when using fixed-length counters.
### Solution
 - - -
