## Sketching
### Definition and properties
Sketching consists of creating compact sketch/summary of data.
```ad-Esempio

```
Sketching is **composable**: if we have data streams $S_1$ and $S_2$ with sketches $\text{sk}(S_1)$ and $\text{sk}(S_2)$, there exists an efficiently computable function $f$ such that:
$$\text{sk}(S_1\cup S_2)=f(\text{sk}(S_1),\text{sk}(S_2))$$
### Simple frequency estimator
Construct a sketch such that can estimate the frequency $f_i$ of any element $i\in[n]$.
First try with an array of counters of width $w$. Counters are all initialized to be zero.
Let's take a pairwise independent hash function $h:[n]\to[w]$.
When item $x$ arrives, it increments the counter $h(x)$:
![[]]
$$\mathbb E[\hat f_i]\le f_i+\dfrac mw$$
We have that:
$$P\left[\hat f_i\ge f_i+2\dfrac mw\right]\le\dfrac12$$

### CountMin Sketch
The CountMin sketch is implemented through a fixed array of counters of width $w$ and depth $d$. As before, all counters are initialized to be zero, but now we have a pairwise independent hash function for each row $h_i:[n]\to[w]$, so when item $x$ arrives, it increments the counter $h_i(x)$ in all rows.
![[CountMin sketch.png]]
```
proc count_min(S):
	initialize d independent hash functions h_j:[n]->[w]
	set counter C_j(b)=0 for all j in [d] and b in [w]
	while S not emtpy:
		if insert(x):
			for j = 1,...,d:
				C_j(h_j(x)) += 1
		else if frequency(i):
			return min_{j in [d]}C_j(h_j(i))
```
The estimator $\hat f_i$ has the following properties:
- $\hat f_i\ge f_i$
- $\hat f_i\le f_i+2\dfrac mw$ with probability at least $1-\left(\dfrac12\right)^d$

If we give values $w=\dfrac2\varepsilon$ and $d=\log_2\left(\dfrac1\delta\right)$, then the estimator bounds are:
- $\hat f_i\ge f_i$
- $\hat f_i\le f_i+\varepsilon m$ with probability at least $1-\delta$

The space consumption is $O(dw)=O\left(2\dfrac{\log_2(1/\delta)}\varepsilon\right)=O\left(\dfrac{\log_2(1/\delta)}\varepsilon\right)$
Query and processing time are both $O(d)=O\left(\log_2\left(\dfrac1\delta\right)\right)$
### Application of CountMin sketch
We can use the CountMin sketch to solve, e.g.:
- heavy hitters problem, i.e., list all elements with frequency at least $\dfrac mk$
- $\text{range}(a,b)$, i.e., return an estimate of the number of elements in the stream with value between $a$ and $b$
### Dyadic intervals
Dyadic intervals are a set of intervals of the form:
$$\left\{\left[j\dfrac n{2^i}+1,\ldots,(j+1)\dfrac n{2^i}\right]|0\le i\le \log_2(n),0\le j\le2^{i-1}\right\}$$
![[dyadic-intervals.png]]
To solve the heavy hitters problem, we can store a CountMin sketch for each level in the tree of dyadic intervals, with the same $d$ and $w$ for all sketches.
On each level, we treat all elements in the same bucket/interval as the same element.
![[]]
- CountMin sketch with universe $[2]$ gives estimated values for $\hat f_{3,1},\hat f_{3,2}$
- CountMin sketch with universe $[4]$ gives estimated values for $\hat f_{2,1},\ldots,\hat f_{3,4}$
- CountMin sketch with universe $[8]$ gives estimated values for $\hat f_{1,1},\ldots,\hat f_{1,8}$
- CountMin sketch with universe $[16]$ gives estimated values for $\hat f_{0,1},\ldots,\hat f_{0,16}$

To find the heavy hitters, we can traverse the tree from the root, and only visit children with estimated frequency $\ge\dfrac mk$.
![[]]
### Analysis
Assume that CountMin sketch makes no large errors:
- the number of intervals queries is $O(k\log_2(n))$
- the query time is $O\left(k\log_2(n)\cdot\log_2\left(\dfrac1\delta\right)\right)$

The space consumption is $O\left(\log_2(n)\cdot\dfrac1\epsilon\log_2\left(\dfrac1\delta\right)\right)$ words.
- - -
## Counting
### Count Sketch
```
proc count_sketch(S):
	initialize d independent hash functions h_j:[n]->[w]
	initialize d independent hash functions s_j:[n]->{-1,1}
	set counter C[j,b]=0 for all j in [d] and b in [w]
	while S not empty:
		if insert(x):
			for j = 1,...,d:
				C[j,h_j(x)] += s_j(i)
		else if frequency(i):
			f = C(h_j(i)) * s_j(i)
			return median(f_{i,j})
```
### Comparison

|                  | Space                                      | Error                            |
| ---------------- | ------------------------------------------ | -------------------------------- |
| **Count-Min**    | $O\left(\dfrac1\epsilon\log(n)\right)$     | $\epsilon F_1$ (one-sided)       |
| **Count-Sketch** | $O\left(\dfrac1{\epsilon^2}\log(n)\right)$ | $\epsilon\sqrt{F_2}$ (two-sided) |
- - -